# Wait for pod to be ready
kubectl wait --for=condition=ready pod/ai-service-vault-test -n application --timeout=120s

# Check secrets
kubectl exec -n application ai-service-vault-test -- cat /vault/secrets/openai.env

# Check ls
kubectl exec -n application ai-service-vault-test -- ls -la /vault/secrets/


kubectl logs ai-service-vault-test -n application -c vault-agent-init

kubectl create secret generic datadog-secret \
  --from-literal=api-key='1002c9085ece68458ac855229c43ba6d' \
  --from-literal=app-key='0f403ee6ab4e075f876364afb6e2b5b3a1f18d25' \
  -n application


Questions:

DataDog Agent Configuration: Your DataDog DaemonSet - does it have APM (Application Performance Monitoring) enabled? The ai-service needs to send traces to DataDog agent.
i am not sure but i have setup with helm charts.

DataDog Site: Which DataDog site are you using? (datadoghq.com, datadoghq.eu, us3.datadoghq.com, etc.) - needed for API queries in AnalysisTemplate.
i had created into datadoghq.com 
Do you want to verify DataDog metrics API is accessible before deploying ai-service?
yes please check


# Check DataDog agent configuration
kubectl get daemonset -n datadog

# Get the DaemonSet details
kubectl get daemonset -l app=datadog -n datadog -o yaml | grep -A 10 "DD_APM_ENABLED"

# Or check ConfigMap if exists
kubectl get configmap -n datadog

# Check DataDog agent pods
kubectl get pods -n datadog

# Check if port 8126 (APM) is listening
kubectl exec -n datadog <datadog-agent-pod-name> -- netstat -tlnp | grep 8126


# Create secret (use your actual keys)
kubectl create secret generic datadog-secret \
  --from-literal=api-key='YOUR_DD_API_KEY' \
  --from-literal=app-key='YOUR_DD_APP_KEY' \
  -n application

# Test API access with a quick pod
kubectl run -n application dd-test --rm -i --tty --image=curlimages/curl -- sh


curl -X GET "https://api.datadoghq.com/api/v1/validate" \
  -H "DD-API-KEY: 1002c9085ece68458ac855229c43ba6d" \
  -H "DD-APPLICATION-KEY: 0f403ee6ab4e075f876364afb6e2b5b3a1f18d25"


  # Example snippet
- name: Build and tag
  run: |
    VERSION="1.0.0"  # or from file/tag
    COMMIT_SHORT=$(git rev-parse --short HEAD)
    IMAGE_TAG="${VERSION}-${COMMIT_SHORT}"
    
    docker build -t $ECR_REPO:$IMAGE_TAG .
    docker push $ECR_REPO:$IMAGE_TAG